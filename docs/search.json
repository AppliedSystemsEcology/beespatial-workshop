[
  {
    "objectID": "04_modelFit.html",
    "href": "04_modelFit.html",
    "title": "Species Distribution Model with Random Forest",
    "section": "",
    "text": "In this module, you’ll build and evaluate a species distribution model for Bombus sitkensis using a Random Forest algorithm. You’ll also generate spatial predictions, evaluate model performance, and visualize variable importance and response curves.",
    "crumbs": [
      "4 Fitting a model"
    ]
  },
  {
    "objectID": "04_modelFit.html#overview",
    "href": "04_modelFit.html#overview",
    "title": "Species Distribution Model with Random Forest",
    "section": "",
    "text": "In this module, you’ll build and evaluate a species distribution model for Bombus sitkensis using a Random Forest algorithm. You’ll also generate spatial predictions, evaluate model performance, and visualize variable importance and response curves.",
    "crumbs": [
      "4 Fitting a model"
    ]
  },
  {
    "objectID": "01_setup.html",
    "href": "01_setup.html",
    "title": "Setup your R environment",
    "section": "",
    "text": "Install packages/setup environment\nWhere to find data if there are issues w/ BeeSpatial, GBIF, LANDFIRE\nDownloading/cloning the github repo\n\n\n\nFor this workshop we will use the renv package to create a reproducible R environment. To initialize the environment first install the renv package.\n\nif (!require(\"renv\")) {\n  install.packages(\"renv\")\n}\n\nlibrary(renv)\n\nThen run renv::restore() to install all of the packages we will use in this workshop.\n\nrenv::restore()\n\n- The library is already synchronized with the lockfile.",
    "crumbs": [
      "1 Setup"
    ]
  },
  {
    "objectID": "01_setup.html#renv",
    "href": "01_setup.html#renv",
    "title": "Setup your R environment",
    "section": "",
    "text": "For this workshop we will use the renv package to create a reproducible R environment. To initialize the environment first install the renv package.\n\nif (!require(\"renv\")) {\n  install.packages(\"renv\")\n}\n\nlibrary(renv)\n\nThen run renv::restore() to install all of the packages we will use in this workshop.\n\nrenv::restore()\n\n- The library is already synchronized with the lockfile.",
    "crumbs": [
      "1 Setup"
    ]
  },
  {
    "objectID": "02_envFeatures.html",
    "href": "02_envFeatures.html",
    "title": "Study Area and Environmental Features",
    "section": "",
    "text": "Identify some landscape online data resources that can be used for insect distribution mapping\nLoad GIS data layers into R and clean and visualize them in preparation for modeling",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#overview",
    "href": "02_envFeatures.html#overview",
    "title": "Study Area and Environmental Features",
    "section": "",
    "text": "Identify some landscape online data resources that can be used for insect distribution mapping\nLoad GIS data layers into R and clean and visualize them in preparation for modeling",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#beespatial",
    "href": "02_envFeatures.html#beespatial",
    "title": "Study Area and Environmental Features",
    "section": "BeeSpatial",
    "text": "BeeSpatial\n\nDownload BeeSpatial data\nBeeSpatial has a point-and-click graphical user interface. You can use it to download raster layers for climate, nesting habitat, and seasonal floral resources. Statewide rasters for these layers can be selected using the Select geographic boundaries option in the Select locations step.\n\n\n\n\n\n\nNote\n\n\n\nSee the BeeSpatial tutorial for more information about this tool.\n\n\n\n\n\nBeeSpatial interface. Preparing to download statewide rasters for Oregon.\n\n\nFor this workshop, we will need the following statewide layers, for Oregon, from BeeSpatial:\n\nMonthly maximum and minimum temperatures for 2020\nMonthly total precipitation for 2020\n\nWe will also be getting pollinator habitat layers from BeeSpatial – more on this later.\n\n\nLoad the downloaded data\n\nlibrary(terra)\n\ndownloadpath &lt;- \"download/Oregon_raster_data/\"   # change to your download location\n\ntmin &lt;- rast(paste0(downloadpath,\"tmin_2020_STATE_FIPS_41.tif\"))\ntmax &lt;- rast(paste0(downloadpath,\"tmax_2020_STATE_FIPS_41.tif\"))\npr &lt;- rast(paste0(downloadpath, \"pr_2020_STATE_FIPS_41.tif\"))\n\nIf we take a look at one of the downloaded climate datasets:\n\npr\n\nclass       : SpatRaster \nsize        : 103, 194, 12  (nrow, ncol, nlyr)\nresolution  : 0.04166667, 0.04166667  (x, y)\nextent      : -124.5625, -116.4792, 41.97917, 46.27083  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource      : pr_2020_STATE_FIPS_41.tif \nnames       : pr202001, pr202002, pr202003, pr202004, pr202005, pr202006, ... \nmin values  :    9.680,    0.000,    8.370,    1.783,    7.118,    0.000, ... \nmax values  : 1598.803,  816.065,  365.797,  335.101,  460.783,  312.381, ... \n\n\nNotice that the downloaded climate data is in geographic coordinates, which is designed for a sphere and uses angles to indicate location and distance. Note that the resolution of each pixel is 0.04166667, 0.04166667  (x, y). These values are in units of degrees. We want to change this to a projected coordinate system, which represents consistent units on the ground and matches with the LANDFIRE data.\n\n\nChange the projection\nWe’re going to use the Universal Transverse Mercator (UTM) zone 10N projection, which works well for the state of Oregon.\n\ntmin &lt;- terra::project(tmin, \"epsg:32610\")   # 32610 indicates the EPSG code for UTM 10N\ntmax &lt;- terra::project(tmax, \"epsg:32610\") \npr &lt;- terra::project(pr, \"epsg:32610\")\n\npr\n\nclass       : SpatRaster \nsize        : 136, 183, 12  (nrow, ncol, nlyr)\nresolution  : 3658.236, 3658.236  (x, y)\nextent      : 370553.5, 1040011, 4647323, 5144843  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 10N (EPSG:32610) \nsource(s)   : memory\nnames       :   pr202001, pr202002,   pr202003,   pr202004,  pr202005,     pr202006, ... \nmin values  :   10.12199,   0.0000,   8.673513,   2.089378,   7.87682, 1.932672e-03, ... \nmax values  : 1453.62988, 779.6107, 321.533447, 327.014679, 455.98788, 2.770888e+02, ... \n\n\nNow looking at the attributes of the climate data, we see that the resolution value is much larger (3658.236, 3658.236  (x, y)). This is because they are now in units of meters. Each pixel of this raster has resolution of roughly 4km. We will use this as a template for the LANDFIRE data layers, since this is our coarsest resolution layer.",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#rlandfire",
    "href": "02_envFeatures.html#rlandfire",
    "title": "Study Area and Environmental Features",
    "section": "rlandfire",
    "text": "rlandfire\n\nDownload rlandfire data\nWe will use rlandfire to get additional landscape data:\n\nElevation\nCanopy cover\n\nAs a first step, load the package and use one of the climate layers (loaded in the previous step) to determine the area of interest (AOI) that we will use to get the LANDFIRE data. We can use the rlandfire function getAOI to do this.\n\nlibrary(rlandfire)\n\naoi &lt;- getAOI(tmin)\naoi\n\n[1] -124.68530   41.79367 -115.99465   46.44474\n\n\nThe AOI is specified in geographic coordinates, with is what is required by the LANDFIRE API that rlandfire is talking to.\nTo request layers with rlandfire we have to specify the LANDFIRE products using their abbreviated names. The layers can be viewed here, which is also accessible using the package function rlandfire::viewProducts(). We will be selecting the elevation layer:\n\nELEV2020 = 2020 elevation\n200CC_20 = canopy cover\n\n\nproducts &lt;- c(\"ELEV2020\", \"200CC_20\")\n\n# additional parameters\nemail &lt;- \"youremail@example.com\"               # Replace with your email\nlfpath &lt;- paste0(getwd(),\"/download/lf.zip\")   # change to your FULL download path\nprojection &lt;- 32610                            # UTM 10N\nresolution &lt;- res(tmin)[1]                     # match climate data resolution\n\nresp &lt;- landfireAPIv2(products = products,\n                    aoi = aoi, \n                    projection = projection,\n                    resolution = resolution,\n                    email = email,\n                    path = lfpath,\n                    verbose = FALSE)\n\n\n\n\n\n\n\nNote\n\n\n\nSee the rlandfire tutorial for more background about these steps.\n\n\n\n\nLoad the downloaded data\nIn order to load the layers into R, unzip the file at the location you indicated in lfpath. We want the file with the extension ‘.tif’. The filename is long and uninformative, so we’ve already renamed it to ‘elevcc.tif’ for these directions. From plotting, we see that the two layers we requested are stacked in a single raster.\n\nelevcc &lt;- rast(paste0(downloadpath, \"elevcc.tif\"))\n\nplot(elevcc)\n\n\n\n\nElevation and canopy cover data from LANDFIRE.",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#prepare-model-inputs",
    "href": "02_envFeatures.html#prepare-model-inputs",
    "title": "Study Area and Environmental Features",
    "section": "Prepare model inputs",
    "text": "Prepare model inputs\nFor our species distribution model, we are planning to use mean precipitation, mean temperature, and elevation as inputs. We already have elevation.\nLet’s look at the climate data from BeeSpatial. This data originates from the PRISM group, which produces weather raster layers from climate station data.\n\nplot(tmin)\n\n\n\n\nContents of the minimum temperature raster.\n\n\n\n\nAs you can see, this data is comprised of 12 layers. Each layer represents the minimum temperature for the month indicated by the last two digits of the layer name, e.g., May of 2020: “tmin202005”. What we want, however, is the mean temperature over the whole year. To get this, we will perform some aggregation.\n\nData aggregation: Calculate annual mean temperature\nTo get a mean annual temperature raster, we will combine the monthly min (tmin) and max (tmax) temperature layers in this way:\n\nAverage tmin and tmax pixels for each month to get a monthly mean –&gt; tmean_mon\nAverage monthly means across the year to get the average temperature for the year –&gt; *tmean_yr**\n\n\nCalculate monthly mean temperature tmean_mon\nWe can calculate the monthly average for each month by simply adding the tmin and tmax rasters and dividing by two. This is possible because these rasters’ layers match so that the first layer (January) of tmin is added to the first layer of tmax and divided by two, etc.\n\ntmean_mon &lt;- (tmin + tmax)/2\n\nplot(tmean_mon)\n\n\n\n\nCalculated mean monthly temperature. The layer names are inherited from tmin.\n\n\n\n\n\n\nCalculate annual mean temperature tmean_yr\nWe simply use mean() to calculate the mean across month layers in the tmean_mon raster.\n\ntmin_yr  &lt;- min(tmin)\ntmax_yr  &lt;- min(tmax)\ntmean_yr &lt;- mean(tmean_mon)\n\nplot(tmean_yr)\n\n\n\n\nCalculated mean annual temperature.\n\n\n\n\n\n\n\nData aggregation: Calculate mean annual precipitation prmean\nCalculating the mean annual precipitation (prmean) uses the same approach as calculating the mean annual temperature from monthly means.\n\nprmean &lt;- mean(pr)",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#make-model-input-layers-align",
    "href": "02_envFeatures.html#make-model-input-layers-align",
    "title": "Study Area and Environmental Features",
    "section": "Make model input layers align",
    "text": "Make model input layers align\nTo overlay these raster day from different sources, we need to check if they have the same projection, resolution, and alignment.\nCheck if the climate data and LANDFIRE data have the same projection. We’re only checking prmean and elev, but you can use the same code to check the other layers.\n\nsame.crs(crs(prmean), crs(elevcc))\n\n[1] TRUE\n\n\nWe expected the projection to be the same because we requested a specific projection in rlandfire.\nCheck if the resolution is the same.\n\nall.equal(res(prmean), res(elevcc))\n\n[1] \"Mean relative difference: 6.449424e-05\"\n\n\nIt looks like there’s a small difference resolution. If you compare the actual values of the climate data (res(prmean)) and elevation (res(elev)), it looks like the LANDFIRE layer only matches the climate layer resolution to the nearest whole number. This means that these layers also don’t align over their extents.\n\nResample\nTo make these layers’ resolution match and their pixels align, we will use resampling. This means transferring the raster data to a new pixel grid. We will do this by matching the elev and cc rasters to that of the climate datasets. To translate the data to the new grid, we will use bilinear interpolation, which takes into account the neighboring cell values for a 3x3 cell window. Be aware that there are other choices that could be made here depending on the type of data we are resampling.\n\n\n\n\n\n\nDownscaling vs. Interpolation\n\n\n\n\n\nIt is worth noting that simple interpolation methods (like bilinear interpolation) only smooth the existing data and they do not add new information or detail to the original course resolution data. For example, if you had 4km weather data and wanted to perform modeling at 1km, resampling with any of the simple interpolation methods would allow you to model at a finer resolution, but the underlying information would still, effectively, be at a 4km resolution. Instead, you would need to use statistical downscaling, dynamic downscaling, or a purpose build machine learning algorithm.\n\n\n\n\nelevcc2 &lt;- resample(elevcc,              # layer to be resampled\n                    prmean,              # target grid to base resampling on\n                    method = \"bilinear\"  # method is bilinear interpolation\n                    )\n\nNow we can check if these layers share the same resolution:\n\nall.equal(res(prmean), res(elevcc2))\n\n[1] TRUE\n\n\nAnd if their extents are the same:\n\nall.equal(ext(prmean), ext(elevcc2))\n\n[1] TRUE",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "02_envFeatures.html#download-pre-processed-habitat-quality-layers",
    "href": "02_envFeatures.html#download-pre-processed-habitat-quality-layers",
    "title": "Study Area and Environmental Features",
    "section": "Download pre-processed habitat quality layers",
    "text": "Download pre-processed habitat quality layers\nThese indices have been summarized to represent the weighted average value within 5km, using an exponential decay function as you go further from a given location (the pixel center). For more information on the forage nesting data, see Koh et al. (2015) and for insecticide use, see Douglas et al. (2022).\nSince these layers are 30m resolution, downloading them for the entire state of Oregon isn’t practical for the workshop. Instead we’ve already processed them using the same projection and resampling steps as above to match the climate data layers.\nThese layers are already in the data/ folder in your workspace. You can also download the pre-processed layers here.\n\n\n\n\n\n\nExtra: Pre-processing steps\n\n\n\n\n\nIn case you’re interested, the code for the pre-processing is below. You will need to download the corresponding layers from BeeSpatial on your own time, however.\n\n# Extra info: Processing 30m pollinator habitat quality layers to match climate layers\n\n# 1. Load 30m layers\nexpath &lt;- \"download/extra/\"      # location of 30m layers\n\nforageFall30m &lt;- rast(paste0(expath, \"Forage_2020_fall_5km_STATE_FIPS_41.tif\"))\nforageSpring30m &lt;- rast(paste0(expath, \"Forage_2020_spring_5km_STATE_FIPS_41.tif\"))\nforageSummer30m &lt;- rast(paste0(expath, \"Forage_2020_summer_5km_STATE_FIPS_41.tif\"))\nnesting30m &lt;- rast(paste0(expath, \"Nesting_2020_5km_STATE_FIPS_41.tif\"))\ninsecticide30m &lt;- rast(paste0(expath, \"Insecticide_2020_5km_STATE_FIPS_41.tif\"))\n\n# 2. Re-project -- projecting the data actually also resamples it. The default method is `bilinear`\nforageFall &lt;- project(forageFall30m, prmean)\nforageSpring &lt;- project(forageSpring30m, prmean)\nforageSummer &lt;- project(forageSummer30m, prmean)\nnesting &lt;- project(nesting30m, prmean)\ninsecticide &lt;- project(insecticide30m, prmean)\n\n# 3. Save the processed layers to your preferred location\n\nwriteRaster(forageFall, \"data/forageFall.tif\")\nwriteRaster(forageSpring, \"data/forageSpring.tif\")\nwriteRaster(forageSummer, \"data/forageSummer.tif\")\nwriteRaster(nesting, \"data/nesting.tif\")\nwriteRaster(insecticide, \"data/insecticide.tif\")",
    "crumbs": [
      "2 Environmental features"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to the Eco-Spatial Workshop!",
    "section": "",
    "text": "This website is the online material for the workshop An Introduction to Eco-spatial Data in R: Accessing, Visualizing, and Applying Machine Learning at Entomology 2025.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#workshop-objectives",
    "href": "index.html#workshop-objectives",
    "title": "Welcome to the Eco-Spatial Workshop!",
    "section": "Workshop Objectives",
    "text": "Workshop Objectives\nBy the end of this course, attendees will be able to:\n\nIdentify some landscape online data resources that can be used for insect distribution mapping\nLoad GIS data layers into R and clean and visualize them in preparation for modeling\nUse an R package to search for and download georeferenced citizen science observation records from the Global Biodiversity Information Facility (GBIF)\nFit a simple species distribution model using the random forest machine learning algorithm\nVisualize the species distribution model results using R",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html",
    "href": "03_occurrenceRecords.html",
    "title": "Occurrence Records",
    "section": "",
    "text": "Retrieve occurrence records for Bombus sitkensis from the Global Biodiversity Information Facility (GBIF)\nProcess these records along with the environmental rasters to create presence and background points to use for fitting the species distribution model",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#overview",
    "href": "03_occurrenceRecords.html#overview",
    "title": "Occurrence Records",
    "section": "",
    "text": "Retrieve occurrence records for Bombus sitkensis from the Global Biodiversity Information Facility (GBIF)\nProcess these records along with the environmental rasters to create presence and background points to use for fitting the species distribution model",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#set-up-gbif-credentials",
    "href": "03_occurrenceRecords.html#set-up-gbif-credentials",
    "title": "Occurrence Records",
    "section": "Set up GBIF credentials",
    "text": "Set up GBIF credentials\nTo download from GBIF, you need to register and supply your registration credentials. More on this here. Or you can use the account info that we’ve provided for this workshop.\nOnce you have your credentials ready, you need to add them to your R environment. The package usethis has a handy function that brings up the file you need to edit to do this:\n\nlibrary(usethis)\n\nusethis::edit_r_environ()\n\nThis will bring up a file called .Renviron. Replace your own credential information below (replace the info in quotes with your info), or you can use the account info that we will provide for this workshop. Then, copy this information into the .Renviron file and save it. You must restart your R session by going to the Session tab &gt; Restart R.\nGBIF_USER=“your_username”\nGBIF_PWD=“your_password”\nGBIF_EMAIL=“youremail@gbif.org”\n\nrenv::restore()\n\n- The library is already synchronized with the lockfile.\n\nlibrary(rgbif)",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#get-the-gbif-taxon-key",
    "href": "03_occurrenceRecords.html#get-the-gbif-taxon-key",
    "title": "Occurrence Records",
    "section": "Get the GBIF taxon key",
    "text": "Get the GBIF taxon key\nAlthough we can search GBIF using the scientific name, this can sometimes return poorly matched results if things like authorship information are missing. We can use the function rgbif::name_backbone() to identify the GBIF taxon key that will return precise taxon matches.\n\nname_backbone(\"Bombus sitkensis\")\n\n# A tibble: 1 × 22\n  usageKey scientificName        canonicalName rank  status confidence matchType\n*    &lt;int&gt; &lt;chr&gt;                 &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;    \n1  1340328 Bombus sitkensis Nyl… Bombus sitke… SPEC… ACCEP…         97 EXACT    \n# ℹ 15 more variables: kingdom &lt;chr&gt;, phylum &lt;chr&gt;, order &lt;chr&gt;, family &lt;chr&gt;,\n#   genus &lt;chr&gt;, species &lt;chr&gt;, kingdomKey &lt;int&gt;, phylumKey &lt;int&gt;,\n#   classKey &lt;int&gt;, orderKey &lt;int&gt;, familyKey &lt;int&gt;, genusKey &lt;int&gt;,\n#   speciesKey &lt;int&gt;, class &lt;chr&gt;, verbatim_name &lt;chr&gt;\n\n\nThe taxon key for Bombus sitkensis is 1340328.",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#set-up-an-rgbif-query",
    "href": "03_occurrenceRecords.html#set-up-an-rgbif-query",
    "title": "Occurrence Records",
    "section": "Set up an rgbif query",
    "text": "Set up an rgbif query\nThere are many query parameters available to narrow down a request for observation records. We are including a few parameters that indicate acceptable-quality data for creating robust distribution maps. These include:\n\nHas geographic coordinates\nHas no geospatial issues\nHas acceptable geospatial coordinate accuracy\nRepresents the presence of the target organism\nWithin a desired time range\nRepresents a human observation\nIs within our focal geographic extent\n\nThe GBIF API has specific search terms (called ‘predicates’ in their domain-specific language) that can specify these parameters. Below we are creating variables to store these values\n\nhasCoordinate &lt;- TRUE\nhasGeospatialIssue &lt;- FALSE\ncoordinateUncertaintyInMeters &lt;- \"0,120\"\noccurrenceStatus &lt;- \"PRESENT\"\nyear &lt;- \"2015,2025\"\nbasisOfRecord &lt;- \"OBSERVATION;HUMAN_OBSERVATION;OCCURRENCE\"\nstateProvince &lt;- \"Oregon\"\ncountry &lt;- \"US\"\n\nNow we can use the function rgbif::occ_count() to preview how many GBIF records we will return if we use these search terms.\n\nocc_count(\n  taxonKey = 1340328,\n  hasCoordinate = hasCoordinate,\n  hasGeospatialIssue = hasGeospatialIssue,\n  coordinateUncertaintyInMeters = coordinateUncertaintyInMeters,\n  occurrenceStatus = occurrenceStatus,\n  year = year,\n  basisOfRecord = basisOfRecord,\n  stateProvince = stateProvince,\n  country = country\n)\n\n[1] 204",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#make-the-gbif-request",
    "href": "03_occurrenceRecords.html#make-the-gbif-request",
    "title": "Occurrence Records",
    "section": "Make the GBIF request",
    "text": "Make the GBIF request\nNow that we know everything works, we make an actual request. We can use the function occ_download() to actually get the data. This function also returns a doi for reproducibility!\n\ngbif_download &lt;- occ_download(\n  pred(\"taxonKey\", 1340328),\n  pred(\"hasCoordinate\", hasCoordinate),\n  pred(\"hasGeospatialIssue\", hasGeospatialIssue),\n  pred_lte(\"coordinateUncertaintyInMeters\",120),\n  pred_gte(\"coordinateUncertaintyInMeters\",0),\n  pred(\"occurrenceStatus\", occurrenceStatus),\n  pred_gte(\"year\", 2015),\n  pred_lte(\"year\", 2025),\n  pred_in(\"basisOfRecord\",c(\"OBSERVATION\",\"HUMAN_OBSERVATION\",\"OCCURRENCE\")),\n  pred(\"country\", country),\n  pred(\"stateProvince\",stateProvince)\n)\n\nWe can check on the status of the download using occ_download_wait and the code provided in the output from running occ_download\n\nocc_download_wait(gbif_download)\n\n\nExample output:\n&lt;&lt;gbif download metadata&gt;&gt;\n  Status: SUCCEEDED\n  DOI: 10.15468/dl.jkj7fd\n  Format: DWCA\n  Download key: 0015030-251009101135966\n  Created: 2025-10-13T19:21:28.361+00:00\n  Modified: 2025-10-13T19:26:19.243+00:00\n  Download link: https://api.gbif.org/v1/occurrence/download/request/0015030-251009101135966.zip\n  Total records: 204\nFinally, once the download is ready, we can get the data:\n\nocc &lt;- occ_download_get(gbif_download) |&gt; occ_download_import()",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#load-environmental-and-habitat-rasters",
    "href": "03_occurrenceRecords.html#load-environmental-and-habitat-rasters",
    "title": "Occurrence Records",
    "section": "Load environmental and habitat rasters",
    "text": "Load environmental and habitat rasters\nThe following steps require the library terra and the environmental and habitat layers from the last section. Load these if you don’t have them in your environment already.\n\nlibrary(terra)\n\nprmean &lt;- rast(\"data/prmean.tif\")\ntmean_yr &lt;- rast(\"data/tmean_yr.tif\")\ntmax_yr &lt;- rast(\"data/tmax_yr.tif\")\ntmin_yr &lt;- rast(\"data/tmin_yr.tif\")\nelevcc &lt;- rast(\"data/elevcc.tif\")\nforageFall &lt;- rast(\"data/forageFall.tif\")\nforageSpring &lt;- rast(\"data/forageSpring.tif\")\nforageSummer &lt;- rast(\"data/forageSummer.tif\")\nnesting &lt;- rast(\"data/nesting.tif\")\ninsecticide &lt;- rast(\"data/insecticide.tif\")\n\n\nRename rasters\nWhen making these rasters, the terra package automatically generates names that aren’t always legible. Here we use the names() &lt;- function to rename the layers to something more understandable.\n\n# rename layers for reference\n\nnames(prmean) &lt;- \"prmean\"\nnames(tmean_yr) &lt;- \"tmean\"\nnames(tmax_yr) &lt;- \"tmax\"\nnames(tmin_yr) &lt;- \"tmin\"\nnames(elevcc) &lt;- c(\"elev\", \"canopycov\")\nnames(forageSpring) &lt;- \"forageSpring\"\nnames(forageSummer) &lt;- \"forageSummer\"\nnames(forageFall) &lt;- \"forageFall\"\nnames(nesting) &lt;- \"nesting\"\nnames(insecticide) &lt;- \"insecticide\"",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#create-occurrence-grid-for-bombus-sitkensis",
    "href": "03_occurrenceRecords.html#create-occurrence-grid-for-bombus-sitkensis",
    "title": "Occurrence Records",
    "section": "Create occurrence grid for Bombus sitkensis",
    "text": "Create occurrence grid for Bombus sitkensis\nWe use the coordinates of the GBIF observations to convert into georeferenced points using the vect function in terra.\n\nocc.vect &lt;- vect(occ[,c(\"decimalLongitude\",\"decimalLatitude\")], \n                 geom = c(\"decimalLongitude\",\"decimalLatitude\"), # x and y columns\n                 crs = \"epsg:4326\")  # WGS 1984 geographic coordinate system\n\nplot(occ.vect)\n\n\n\n\n\n\n\n\n\nConvert the observed points to grid cells\nUsing one of the environmental grids as a template, we convert the observation points from GBIF to a presence grid, where a grid cell value of 1 indicates that (any number of) observations were reported in that cell.\n\nocc.rast &lt;- rasterize(occ.vect |&gt; \n                        terra::project(prmean),   # project points to match projection\n                      prmean                      # template raster\n                      )\n\n# rename the raster layers for reference\n\nnames(occ.rast) &lt;- \"B_sitkensis\"\n\nplot(occ.rast)\n\n\n\n\n\n\n\n\n\n\nCombine presence grid with environment and habitat variables and extract to table\nWe only need a table of presence grid cells and their associated habitat and environmental values. To do this, we can stack all the raster layers together (since they share the same projection and their grids are aligned). Then we can use the terra values function to extract the cell values of the stacked grids as rows in a table, keeping only the rows with B. sitkensis presences using the filter function from dplyr.\n\nlibrary(dplyr)\n\n# stack then environmental and habitat layers and the rasterized occurence points\n\nocc.envr &lt;- rast(list(prmean, tmean_yr, tmax_yr, tmin_yr, elevcc, forageFall,\n                      forageSpring, forageSummer, nesting, insecticide, occ.rast))\n\n\npresence &lt;- as.data.frame(occ.envr, xy = TRUE) |&gt; \n  na.omit()   # drop rows where B_sitkensis occurence is NA",
    "crumbs": [
      "3 Occurrence records"
    ]
  },
  {
    "objectID": "03_occurrenceRecords.html#create-background-points-grid",
    "href": "03_occurrenceRecords.html#create-background-points-grid",
    "title": "Occurrence Records",
    "section": "Create background points grid",
    "text": "Create background points grid\nBackground samples are obtained randomly and independently of species locations. Background points are meant to sample the full environmental space available to the species of interest in the region. This means that background points:\n\nshould be numerous enough to represent the environmental variation across the region\nmay overlap with the presence points\n\nThe package predicts has a function that is useful for creating background points, backgroundSample.\n\nlibrary(predicts)\n\nset.seed(100)   # background sampling is random. Setting seed to 100 ensures we get the same results\n\nbackgroundpts &lt;- backgroundSample(\n  mask = forageFall,           # mask restricts points to area of interest (defined by the forageFall)\n  n = 10000,                   # create 10000 background points\n)\n\nbackground &lt;- terra::extract(occ.envr[[1:11]],    # only extracting the environmental/habitat layers\n                      backgroundpts               # extraction locations\n                      )\n\n# combine presence and background data\n\npresback &lt;- bind_rows(presence, background) |&gt;\n  mutate(B_sitkensis = ifelse(is.na(B_sitkensis), 0, B_sitkensis))   # replace NA (from background data) with 0\n\nSave the output!\n\nsaveRDS(presback, \"data/presback.rds\")\nsaveRDS(occ.envr, \"data/occ.envr.rds\")",
    "crumbs": [
      "3 Occurrence records"
    ]
  }
]